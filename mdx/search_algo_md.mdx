![](https://media0.giphy.com/media/S8TsC0rUwf9xGA3Hx7/giphy.gif?cid=ecf05e47errwly7lmyl3tcdmj09sf13xzhctkz9j2djqednk&rid=giphy.gif&ct=g)

# TL;DR  
코드업 문제집에서 '탐색기반설계'와 '관계기반설계' 라는 말을 만나 어떤 말인지 궁금해 조사하여 정리해보았다.  
>**참고문헌**
>- [탐색공간의 배제(Exclusion of Search Space)](https://lemidia.github.io/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/)
>- [알고리즘 심화 - 관계기반 알고리즘의 설계](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bestmaker0290&logNo=220871525608)

---

# 탐색기반설계, 관계기반설계가 뭔데? 🤔
정보과학에서는 알고리즘을 크게 두가지 방법을 통해 설계하는데, 바로 **탐색기반설계**와 **관계기반설게**이다.  

---

# 탐색기반설계 🎒
탐색 기반 설계는 **컴퓨터의 빠른 연산을 이용하여 짧은 시간안에 가능한 해 집합을 모두 탐색**하면서 해를 구하는 방법이다.  
짧은 시간안에 가능한 해 집합을 모두 탐색하기 위해 **배제**를 통해 탐색시간을 줄인다.

## 1. 경험적 배제
경험적 배제는 전체탐색법을 기본으로 한 알고리즘 설계 방법이다.  
처음 시작은 전체탐색과 마찬가지로 해가 될 수 있는 모든 공간을 탐색해 나간다. 차이점이라면 특정 조건을 두고 계속 탐색 할지 여부를 정한다. **즉, 더 탐색해도 해를 발견할 가능성이 없다면 탐색을 멈춘다.**

이 조건의 설정은 알고리즘이 시작될 때는 정할 수 없고, 탐색을 진행하는 중에 조건을 설정하고, 탐색한 영역이 넓어질수록 상황에 따라 조건이 갱신된다. 따라서 탐색한 정보, 즉 경험한 정보를 이용해서 배제할 조건을 정하기 때문에 경험적 배제라고 한다.


![](./images/graph.png)

다음과 같은 그래프를 예시로 보자. 각 번호는 탐색하는 순서를 의미한다.  
만약 3번 노드가 문제의 조건을 만족한다면, 우리는 4, 5, ... 의 5개 노드를 탐색할 필요가 없어진다. 11개의 노드를 탐색해야 했던것이 6개의 노드만 탐색하면 되는 것 이다.  

**즉, Bounding(=Cutting)을 통해 연산 횟수를 줄일 수 있다.**

이렇게 Bounding을 하는 알고리즘의 효율은 **처음에 구한 해가 얼마나 질이 좋은 해**인가에 따라 결정된다. 그렇다면 초반에 질이 좋은 해를 어떻게 구할 수 있을까?  

**단순 탐욕법**이란 탐욕법의 한 종류로 현재 상태에서 수학적 검증 없이 **현재 상태에서 가장 유리한 상태만을** 탐색하는 방법이다. 이 방법은 최적해를 구할 수 있다는 보장은 없지만 비교적 **질이 좋은 해**를 구할 수 있다.  

따라서 단순 탐욕법을 통해 처음에 하나의 해를 구해 이를 탐색 베제의 조건으로 삼는다면 알고리즘의 평균적인 효율이 향상될 것이다.

## 2. 수학적 배제
탐색 공간 중 배제할 영역을 수학적 증명으로 결정하는 방법이다. 대표적인 예시로는 '수학적 탐욕법', 이분탐색 알고리즘' 등 을 들 수 있다.  
수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다.  

수학적 배제의 방법으로 다음 문제를 푸는 알고리즘을 설계해보자.
>{"한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오. (단, 1 <= n <= 100억)"}

문제를 풀기 위해 간단히 예를 들어 n을 10으로 놓자.  
10의 약수는 `1, 2, 5, 10` 이다. 여기서 약수의 규칙을 발견 할 수 있다.  
**1과 10은 10의 약수일 수 밖에 없다. 그리고 양끝에서 부터 짝지었을때 `(1, 10)`, `(2, 5)`는 모두 곱이 10으로 나타난다.**

즉, n의 약수를 구하기 위해 `sqrt(n)`까지 탐색하고 특정 약수 `i`에 대응하는 약수는 `n/i`로 구하면 된다.
```c
#include <math.h>
#include <stdio.h>

int getSum(int n) {
	int sum=1+n;
	for(int i=2; i<sqrt(n); i++)
		if(!(n%i))
			sum+=i+n/i;
	if(sqrt(n)*sqrt(n)==n)
		sum+=sqrt(n);
	return sum;
}

int main(void) {
	int n;
	scanf("%d", &n);
	printf("%d", getSum(n));
}
```

---

# 관계기반설계 🤖
관계기반 설계는 **해를 구하는 행위를 하나의 함수로 표현한 뒤, 이 함수들의 관계를 이용해 해를 구하는 방법**이다.  

관계기반 설계를 사용하기 위해서는 다음과 같은 조건이 필요하다.
>- 문제의 정의 및 상태를 함수로 정의할 수 있어야 한다.
>- 이 함수들의 관계를 점화식 또는 유사한 형태로 표현할 수 있어야 한다.

관계기반설계는 중간고사 때 우리들을 괴롭혔던 **수학적 귀납법**을 정보과학에 응용한 형태라고 할 수 있다. 수학적 귀납법을 증명이 아닌 문제의 해결에 사용하는 것이다.

>**관계기반설계**
>1. 입력값이 n인 문제의 해를 `f(n)`으로 정의한다.
>2. `f(1)`을 직접 구한다. → 이 단계를 **basis**라 한다.
>3. `f(k)`를 구해두었다고 가정하고 `f(k)`를 통해 `f(n)`을 구하여 출력한다. → 이 단계를 **induction**이라 한다.

예를 들어 1부터 n까지의 합을 구하는 문제에서는
>1. n까지의 합을 `f(n)`으로 둔다.
>2. `f(1)=1` 이다.
>3. `f(n-1)+n=f(n)` 이다.

즉, `f(1)=1`이라는 basis와 `f(n-1)+n=f(n)`라는 induction을 통해 재귀적으로 문제를 정의할 수 있다.  
[재귀함수를 바라보는 또다른 관점은 여기서 볼 수 있다.](/jaegui)