import Latex from 'react-latex-next'

![](https://velog.velcdn.com/images/given-woo/post/68f0717a-2ef4-472b-a5c4-499be3aefecb/image.gif)

# TL;DR
**[이 글은 제 velog의 글을 next.js로 작성한 블로그에 옮긴 것 입니다 :D](https://velog.io/@given-woo/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EB%9E%91-%EC%B9%9C%EA%B5%AC%EB%A8%B9%EA%B8%B0)**

>"재귀함수는 어렵다"  
>"재귀함수는 머리가 좋아야한다"  

재귀함수를 공부할때 정말 많이 들었던 말이다.  
이 글에서는 재귀함수를 바라보는 새로운 관점을 제시하여 여러분이 재귀함수랑 짱친을 먹을 수 있도록 도와주겠다.  

---

# 재귀함수는 왜 어렵지? 🤯  
여러분들이 재귀함수를 어렵다고 하는 이유는 보통 다음과 같다.  

>1. **어떤 재귀함수**를 짤지 정하지 못하겠다.  
>2. **인자**로 무엇을 받고 **반환**할지 모르겠다.  
>3. **종료조건**을 어떻게 설정할지 모르겠다.  

**따라서 이 3가지에 초점을 두고 재귀함수를 더 쉽게 바라볼 수 있는 훈련을 할 것이다.**  

---

# 어? 어디서 봤는데? 🎒
자랑스러운 부산일과학고등학교 학생이라면 재귀함수를 바라보면서 무언가가 떠올랐을 것이다. 바로 **수열**이다.

수열을 정의하는 방법은 크게 두가지라 할 수 있다. 일반항을 제시하는 것과 **점화식**을 제시하는 방법이다. 그리고 점화식에는 **첫째항**이 주어져야한다.

## 1. 아 점화식!
중간고사때 우리를 괴롭혔던 점화식이 어딘가 재귀함수랑 많이 닮지 않았는가? 더 쉽게 예를 들어보겠다.
1부터 n항 까지의 합을 수열을 <Latex>$a_n$</Latex>이라 한다면 이를 점화식으로 다음과 같이 나타낼 수 있다.  
> <Latex>$a_1=1$</Latex>  
> <Latex>{"$a_n=a_{n-1}+n$ $(n>1)$"}</Latex>

## 2. 재귀함수야 가보자고~
위의 점화식을 보자. 이제 뭔가 눈에 보일 것 이다. 이 수열을 재귀함수로 나타낼 수 있을 것만 같다.  
점화식에서 1에서 n까지의 합을 재귀함수 `sum(n)` 으로 나타내었을 때 `sum(n) == sum(n-1) + n` 이 성립함이 눈에 들어온다. 또한 종료조건으로 `sum(1) == 1` 을 사용하면 됨도 바로 눈에 들어온다. 이를 파악했다면 재귀함수도 작성할 수 있을 것이다.
```c
int sum(int n) {
	if(n==1)
    	return 1;
	return n+sum(n-1);
}
```
즉, "재귀함수만 생각하면 머리가 핑도는" 상태라면 **어떤 "재귀함수"를 짤지 생각하지말고 어떤 "수열"을 짤지 생각을 하자.** 점화식으로 수열을 표현하면 그 다음 과정은 굉장히 쉬울것이다.

---

# 재귀함수를 짜보자! 💻
위의 과정을 거쳤다면 재귀함수와 처음보다는 훨씬 친해진 느낌이 들것이다.  
이제 위의 과정을 바탕으로 다른 재귀함수들도 짜보자. 해답을 읽지 말고 제목만 읽고 점화식을 찾은 후, 재귀함수를 짜보는 것을 추천한다.  

## 1. 피보나치 수열
피보나치 수열을 <Latex>$F_n$</Latex>으로 두면 다음이 성립한다.  
><Latex>$F_1=1$, $F_2=1$</Latex>  
><Latex>{"$F_n=F_{n-1}+F_{n-2}$ $(n>2)$"}</Latex>

이걸 재귀함수로 다음과 같이 나타낼 수 있다.
```c
int fib(int n){
	if(n==1||n==2)
		return 1;
	return fib(n-1)+fib(n-2);
}
```

## 2. 팩토리얼
<Latex>$a_n=n!$</Latex> 이라 하면 다음이 성립한다.
><Latex>$a_1=1$</Latex>  
><Latex>{"$a_n=a_{n-1}\\times n$ $(n>1)$"}</Latex>

이걸 재귀함수로 다음과 같이 나타낼 수 있다.

```c
int fact(int n) {
	if(n==1)
		return 1;
	return fact(n-1)*n;
}
```

---

# 빨리빨리! 🕓
한국인은 '빨리빨리'를 많이 한다고 한다.  
우리 재귀함수 친구도 한국인인지 시간복잡도를 줄여서 더 빨라지고 싶어 한다. 이 친구의 시간복잡도를 줄이기 위해 우리는 **메모이제이션(memoization)** 기법을 사용할 수 있다.  

## 1. 뭐가 문제지?
본격적으로 메모이제이션을 배우기 전 왜 느려지는지 부터 확인하자.  
아래는 위의 피보나치 수 재귀함수에서 `Fib(6)` 을 계산하기 위해 일어나는 일이다.  

![](https://velog.velcdn.com/images/given-woo/post/2daacede-af80-49bc-87e5-cfd1b5068d36/image.png)

위의 그림에서 볼 수 있듯 이 재귀함수는 굉장히 비효율적이다. 계산해둔 값을 전혀 활용하지 않고 다시 계산하고 있기 때문이다.  
`F(6)` 하나를 계산하면서 `F(3)` 을 무려 3번이나 다시 계산했다. 이게 6번째 피보나치 수라서 그렇지 1000번째, 10000번째 피보나치 수를 계산할 때에는 굉장히 많은 불필요한 연산들이 발생할 것이다.  
**만약 우리가 계산해둔 값을 저장해두고 다시 활용한다면 속도가 빨라지지 않을까?**

## 2. 메모이제이션!
이러한 생각에서 나온 메모이제이션은 이름이 굉장히 간지나지만 사실 아무것도 아니다.   
**계산한 값을 배열에 저장하고 다시 활용하는 것이다.**  

코드를 보며 이해해보자.

```c
int memo[101]={};

int fib(int n) {
	if(n==1||n==2)
		return 1;
	if(memo[n]!=0)
		return memo[n];
	return memo[n]=fib(n-1)+fib(n-2);
}
```
조금 길어졌다고 겁먹지 말자. 모습은 달라졌지만 우리의 짱친 재귀함수다.  
처음 짰던 코드와 달리 `memo` 가 등장한 것을 볼 수 있다. 얘는 **재귀함수의 연습장**이라고 생각하면 된다. **계산을 하지 않았던 값이라면 연습장에 기록을 하고, 연습장을 뒤졌을 때 계산이 이미 되어있다면 이걸 그대로 적는 것**이다.

이렇게 하면 한번 계산한 값을 계속 저장이 되니 다시 계산을 반복할 일이 없다.

---

# 문제를 풀어봅시다~ 🧑🏻‍💻
메모이제이션 까지 모두 마쳤다면 재귀함수와 굉장한 짱친이 되었을 것이다.  
우린 이제 무서울게 없다. 코드업에 문제를 풀러 가보자!  
**[풀이는 여기서 확인할 수 있다.](https://velog.io/@given-woo/%EC%BD%94%EB%93%9C%EC%97%85-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C)**